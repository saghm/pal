use std::str::FromStr;

use ast::{Value, BinOp, Expr, Statement};
use token::{self, Token};

grammar<'input>(text: &'input str);

// Macros -----------------------------------------------------------------------------------------

BinExp<Op, NextLevel>: Expr = {
    <b:BinExp<Op, NextLevel>> <o:Op> <n:NextLevel> =>
        Expr::BinExp(Box::new(b), o, Box::new(n)),
    NextLevel,
};

// Statements -------------------------------------------------------------------------------------

pub Stmt = {
    SingleStmt,
    If,
};

SingleStmt: Statement = {
    <Ident> "=" <Exp> ";" => Statement::Assign(<>),
    "let" <Ident> "=" <Exp> ";" => Statement::Let(<>),
    "print" <Exp> ";" => Statement::Print(<>),
    "if" <c:Clause> <b1:Block> "else" <b2:Block> => Statement::If(c, b1, b2),
};

If: Statement = {
    "if" <c:Clause> <b:Block> => Statement::If(c, b, vec![]),
    "if" <c:Clause> <b:Block> "else" <i:If> => Statement::If(c, b, vec![i]),
};

Block= "{" <Stmt+> "}";
Clause = "(" <Exp> ")";

// Expressions ------------------------------------------------------------------------------------

Exp: Expr = OrExp;

OrExp = BinExp<OrOp, AndExp>;
OrOp: BinOp = "||" => BinOp::Or;

AndExp = BinExp<AndOp, EqExp>;
AndOp: BinOp = "&&" => BinOp::And;

EqExp = BinExp<EqOp, InEqExp>;
EqOp: BinOp = {
    "=" "=" => BinOp::Equal,
    "!" "=" => BinOp::NotEqual,
};

InEqExp = BinExp<InEqOp, AddExp>;
InEqOp: BinOp = {
    ">" "=" => BinOp::GreaterOrEqual,
    ">" => BinOp::GreaterThan,
    "<" "=" => BinOp::LessOrEqual,
    "<" => BinOp::LessThan,
};

AddExp = BinExp<AddOp, MulExp>;
AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

MulExp = BinExp<MulOp, NotExp>;
MulOp: BinOp = {
    "*" => BinOp::Times,
    "/" => BinOp::Divide,
    "%" => BinOp::Modulus,
};

NotExp: Expr = {
    "!" <NotExp> => Expr::Not(Box::new(<>)),
    Term,
};

Term: Expr = {
    Ident => Expr::Var(<>),
    Value => Expr::Value(<>),
    "(" <Exp> ")",
};


Value: Value = {
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
    Int => Value::Int(<>),
};

Int: i64 = "I64" => i64::from_str(<>).unwrap();
Ident: String = "Ident" => String::from(<>);

extern {
    type Location = usize;
    type Error = token::Error;

    enum Token<'input> {
        "true" => Token::True,
        "false" => Token::False,
        "I64" => Token::I64(<&'input str>),
        "Ident" => Token::Ident(<&'input str>),
        "let" => Token::Let,
        "print" => Token::Print,
        "if" => Token::If,
        "else" => Token::Else,
        "!" => Token::Bang,
        "&&" => Token::DoubleAmp,
        "||" => Token::DoubleBars,
        "=" => Token::Equal,
        ">" => Token::GreaterThan,
        "<" => Token::LessThan,
        "-" => Token::Minus,
        "%" => Token::Percent,
        "+" => Token::Plus,
        "/" => Token::Slash,
        "*" => Token::Star,
        ";" => Token::Semicolon,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftBrace,
        "}" => Token::RightBrace,
    }
}
