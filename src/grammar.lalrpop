use std::str::FromStr;

use ast::{BinOp, Expr, Statement, Type, Value};
use token::{self, Token};

grammar<'input>(text: &'input str);

// Macros -----------------------------------------------------------------------------------------

BinExp<Op, NextLevel>: Expr = {
    <b:BinExp<Op, NextLevel>> <o:Op> <n:NextLevel> =>
        Expr::BinExp(Box::new(b), o, Box::new(n)),
    NextLevel,
};

List<T>: Vec<T> = {
    <T> => vec![<>],
    <l:List<T>> "," <t:T> => {
        let mut v = l;
        v.push(t);
        v
    }
};

ParenList<T>: Vec<T> = "(" <List<T>?> ")" => <>.unwrap_or(Vec::new());


// Statements -------------------------------------------------------------------------------------

pub Stmt: Statement = {
    SimpleStmt,
    <Type> <Ident> <Params> <Block> => Statement::Defun(<>),
};

SimpleStmt = {
    SingleStmt,
    If,
};

SingleStmt: Statement = {
    <Ident> "=" <Exp> ";" => Statement::Assign(<>),
    "let" <Ident> "=" <Exp> ";" => Statement::Let(<>),
    "print" <Exp> ";" => Statement::Print(<>),
    "if" <c:Clause> <b1:Block> "else" <b2:Block> => Statement::If(c, b1, b2),
    "while" <c:Clause> <b:Block> => Statement::While(c, b),
    <Ident> <ParenList<Exp>> ";" => Statement::VoidCall(<>),
    "return" <Exp> ";" => Statement::Return(<>),
};

If: Statement = {
    "if" <c:Clause> <b:Block> => Statement::If(c, b, vec![]),
    "if" <c:Clause> <b:Block> "else" <i:If> => Statement::If(c, b, vec![i]),
};

Block = "{" <SimpleStmt*> "}";
Clause = "(" <Exp> ")";

IdentList = List<Ident>;
Params = ParenList<Ident>;

Type: Type = {
    "boolean" => Type::Bool,
    "int" => Type::Int,
    "string" => Type::Str,
    "void" => Type::Void,
};

// Expressions ------------------------------------------------------------------------------------

Exp: Expr = OrExp;

OrExp = BinExp<OrOp, AndExp>;
OrOp: BinOp = "||" => BinOp::Or;

AndExp = BinExp<AndOp, EqExp>;
AndOp: BinOp = "&&" => BinOp::And;

EqExp = BinExp<EqOp, InEqExp>;
EqOp: BinOp = {
    "=" "=" => BinOp::Equal,
    "!" "=" => BinOp::NotEqual,
};

InEqExp = BinExp<InEqOp, AddExp>;
InEqOp: BinOp = {
    ">" "=" => BinOp::GreaterOrEqual,
    ">" => BinOp::GreaterThan,
    "<" "=" => BinOp::LessOrEqual,
    "<" => BinOp::LessThan,
};

AddExp = BinExp<AddOp, MulExp>;
AddOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
};

MulExp = BinExp<MulOp, NotExp>;
MulOp: BinOp = {
    "*" => BinOp::Times,
    "/" => BinOp::Divide,
    "%" => BinOp::Modulus,
};

NotExp: Expr = {
    "!" <NotExp> => Expr::Not(Box::new(<>)),
    Call,
};

Call: Expr = {
    <Ident> <ParenList<Exp>> => Expr::Call(<>),
    Term,
};

Term: Expr = {
    Ident => Expr::Var(<>),
    Value => Expr::Value(<>),
    "(" <Exp> ")",
};

Value: Value = {
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
    Int => Value::Int(<>),
    Str => Value::Str(<>),
};

Int: i64 = "I64" => i64::from_str(<>).unwrap();
Ident: String = "Ident" => String::from(<>);
Str: String = "StringLit" => String::from(<>);

extern {
    type Location = usize;
    type Error = token::Error;

    enum Token<'input> {
        "true" => Token::True,
        "false" => Token::False,
        "I64" => Token::I64(<&'input str>),
        "Ident" => Token::Ident(<&'input str>),
        "let" => Token::Let,
        "print" => Token::Print,
        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "return" => Token::Return,
        "boolean" => Token::Boolean,
        "int" => Token::Int,
        "string" => Token::Str,
        "void" => Token::Void,
        "!" => Token::Bang,
        "&&" => Token::DoubleAmp,
        "||" => Token::DoubleBars,
        "=" => Token::Equal,
        ">" => Token::GreaterThan,
        "<" => Token::LessThan,
        "-" => Token::Minus,
        "%" => Token::Percent,
        "+" => Token::Plus,
        "/" => Token::Slash,
        "*" => Token::Star,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftBrace,
        "}" => Token::RightBrace,
        "StringLit" => Token::StringLiteral(<&'input str>),
    }
}
